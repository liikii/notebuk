initial program
bootstrap program
read-only memory (ROM
 bootstrap program locate the operating-system kernel and load it into memory.
system prcess system daemon
hardware interrupt   software interrupt, system call.


When the CPU is interrupted, it stops what it is doing and immediately transfers execution to a fixed location. The fixed location usually contains the starting address where the service routine for the interrupt is located.

More recent architectures store the return address on the system stack. 
 small computer-systems interface (SCSI) controller
 A device controller maintains some local buffer storage and a set of special-purpose registers. 
 device driver  device controller 


 To start an I/O operation, the device driver loads the appropriate registers within the device controller. The device controller, in turn, examines the contents of these registers to determine what action to take (such as “read a character from the keyboard”). The controller starts the transfer of data from the device to its local buffer. Once the transfer of data is complete, the device controller informs the device driver via an interrupt that it has finished its operation. The device driver then returns control to the operating system, possibly returning the data or a pointer to the data if the operation was a read. For other operations, the device driver returns status information.


 multiprocessor systems (also known as parallel systems or multicore systems) 

 The set of jobs in memory can be a subset of the jobs kept in the job pool. 


  job scheduling, if several jobs are ready to be brought into memory, and if there is not enough room for all of them, 

swapping, virtual memory

al ax eax disp8 disp32  cl cx ecx dl dx edx bl bx ebx SIB Mode ah sp esp ch bp ebp esi dh si esi edi bh di edi

https://www.byclb.com/TR/Tutorials/microprocessors/ch3_1.htm
SIP: scaled index address mode: just for index array.


http://52.80.126.45:8081/


 curl -vX GET http://52.80.126.45:8081/api/aikfs/v1/huxing/user/history/list
jia-test.lbadvisor.com/
 curl -vX GET http://jia-test.lbadvisor.com/api/aikfs/v1/huxing/user/history/list
https://www.ragestorm.net/downloads/286intel.txt


●  A displacement element in the instruction.
●  A base register.
●  An index register. The index register may be automatically multiplied by a scaling factor of 2, 4, or 8.
查数组， 一个基地址， 一个

 MOD-REG-R/M: mode: 8 bit, reg: 8 big, r/m: regist or memory. 



https://github.com/QSCTech/zju-icicles


ret: 
return save previous EIP on stack.



memory:::

d: offset, displacement.
p: p to page table,.
logical address: 
cpu: p * 8 + d
Memory Paging is yet another 386 feature that permits extending the address space far beyond 4 Gb.

Address generated by CPU (logical address) is divided into:

Page number p is an index into a page table that contains base address of each page in physical memory.

Page offset d is a displacement, combined with base address to define the physical memory address that is sent to the memory unit.





protected mode:::
32-bit Protected Mode supports much larger data structures than Real mode.

Because code, data, and stack reside in the same segment, each segment register can hold the same value that never needs to change.

Rather than using a formula (such as CS:IP) to determine the physical address, protected mode processors use a look up table.

Segment registers simply point to OS data structures that contain the information needed to access a location.

Protected mode uses privilege levels to maintain system integrity and security.

Programs cannot access data or code that is in a higher privilege level.

(Segment value exchanges at the same privilege level are allowed.)




segment registers in protected mode:


Segment registers are called selectors when operating in protected mode.
Segment registers are called selectors when operating in protected mode.

In protected mode, segment registers simply point to data structures called segment descriptors that contain the information needed to access a physical memory location.


Segment selector is a segment register, containing the selector value:

  Segment selector

13-bit index field selects one of 8,192 segment descriptors.

TI (table indicator) specifies segment descriptor, which can be in

GDT - global descriptor table (one for all programs)

LDT - local descriptor table (typically one for each program, more can exist.)

IDT - interrupt descriptor table.


--------------------------


protected mode architecture:
Segment register (segment selector) -> segment descriptor -> physical memory

--------------------------

Understanding segments is an essential part of programming in assembly language.

--------------------------
protected mode:::
For example, a code fetch always uses the current CS. A protected mode fetch starts by multiplying CS by 8 and then adding the descriptor base register. The 386 then reads an entire 8 byte record from the descriptor table. The entry describes the start of the segment; the processor adds the current instruction pointer to this start to get an effective address.


A data access behaves the same way. A load from location DS:1000 makes the processor read a descriptor by shifting DS left 3 bits (i.e., times 8), adding the table's base address (stored in the 386's on-board descriptor table register), and reading the 8 byte descriptor at this address. The descriptor contains the segment's start address, which is added to the offset in the instruction (in this case 1000). Offsets, and segment start addresses, are 32 bit numbers - it's really easy to reference any location in memory.

Every memory access works through these 8 byte descriptors. If they were stored only in user RAM the 386's throughput would be pathetic, since each memory reference needs the information. Can you imagine waiting for an 8 byte read before every memory access? Actually, the processor caches a descriptor for each selector (one for CS, one for DS, etc) on-chip, so the segment translation requires no overhead. However, every load of a selector (like MOV DS,AX or POP ES) will make the 386 stop and read all 8 bytes to it's internal cache, slowing things down just a bit.

descriptor created by:::
The segment descriptor provides the processor with the data it needs to map a logical address into a linear address. Descriptors are created by compilers, linkers, loaders, or the operating system, not by applications programmers.





segment register:
visible portion, invisible portion.
invisible portion: segment base, segmnet limit, access rights.


page register in ther cr3 register.
The physical address of the current page directory is stored in the CPU register CR3, also called the page directory base register (PDBR)



why protection::

Protection in the 80386 has five aspects:
  1.  Type checking
  2.  Limit checking
  3.  Restriction of addressable domain
  4.  Restriction of procedure entry points
  5.  Restriction of instruction set



segment-level protection:
Segment-Level Protection
All five aspects of protection apply to segment translation:
  1.  Type checking
  2.  Limit checking
  3.  Restriction of addressable domain
  4.  Restriction of procedure entry points
  5.  Restriction of instruction set
The segment is the unit of protection, and segment descriptors store protection parameters. Protection checks are performed automatically by the CPU when the selector of a segment descriptor is loaded into a segment register and with every segment access. Segment registers hold the protection parameters of the currently addressable segments.


descriptor:::
Descriptors Store Protection Parameters
Figure 6-1 highlights the protection-related fields of segment descriptors.
The protection parameters are placed in the descriptor by systems software at the time a descriptor is created. In general, applications programmers do not need to be concerned about protection parameters.
When a program loads a selector into a segment register, the processor loads not only the base address of the segment but also protection information. Each segment register has bits in the invisible portion for storing base, limit, type, and privilege level; therefore, subsequent protection checks on the same segment do not consume additional clock cycles.


data segment descriptor,executable segment descriptor, system segment descriptor.
A   - ACCESSED
AVL - AVAILABLE FOR PROGRAMMERS USE
B - BIG
C   - CONFORMING
D - DEFAULT
DPL - DESCRIPTOR PRIVILEGE LEVEL
E   - EXPAND-DOWN
G   - GRANULARITY
P   - SEGMENT PRESENT
R   - READABLE
W   - WRITABLE




descriptor type::

Table 6-1. System and Gate Descriptor Types
Code      Type of Segment or Gate
0 -reserved
1       Available 286 TSS
2 LDT
3 Busy 286 TSS
4 Call Gate
5 Task Gate
6       286 Interrupt Gate
7       286 Trap Gate
8 -reserved
9       Available 386 TSS
A -reserved
B Busy 386 TSS
C       386 Call Gate
D -reserved
E       386 Interrupt Gate
F       386 Trap Gate


TSS::
Task state segment



flat model
When the 80386 is used to execute software designed for architectures that don't have segments, it may be expedient to effectively "turn off" the segmentation features of the 80386. The 80386 does not have a mode that disables segmentation, but the same effect can be achieved by initially loading the segment registers with selectors for descriptors that encompass the entire 32-bit linear address space. Once loaded, the segment registers don't need to be changed. The 32-bit offsets used by 80386 instructions are adequate to address the entire linear-address space.



：：：segments spanning serveral pages.:
The structure is divided into 33 pages, any number of which may not be present. The applications programmer does not need to be aware that the virtual memory subsystem is paging the structure in this manner.




：：：5.3.3  Pages Spanning Several Segments
semaphore
it may be useful to cluster many related segments within a page.




::: non aligned  (page  segment ) boundaries
::: aligned (page segment ) boundaries




memory management :
segmentation, paging:
segmentation: for isolating code, data and statck  modeules .
paging: mapped into physical memory when needed.



memory mapging::
when accessing memory page that is not in physical memory, an exception is generated.the exception allows the supervisor software to load required page transparently to the user program.



page directory address: cr3 (32-12)+ directory part(31-21) of linear address.

cr3 define the page directory address. 
linear directory part define the permission bit.



:::load descriptor, also load protection information.
When a program loads a selector into a segment register, the processor loads not only the base address of the segment but also protection information. Each segment register has bits in the invisible portion for storing base, limit, type, and privilege level; therefore, subsequent protection checks on the same segment do not consume additional clock cycles.


::: check by hardware.
Each reference to memory is checked by the hardware to verify that it satisfies the protection criteria. 


:: expand-down feature.
The expand-down feature makes it possible to expand the size of a stack by copying it to a larger segment without needing also to update intrastack pointers.



::::A call gate has two primary functions:
1. To define an entry point of a procedure.
2. To specify the privilege level of the entry point.


To maintain system integrity, each privilege level has a separate stack. These stacks assure sufficient stack space to process calls from less privileged levels. Without them, a trusted procedure would not work correctly if the calling procedure did not provide sufficient space on the caller's stack.



When a call gate is used to change privilege levels, a new stack is
selected by loading a pointer value from the Task State Segment (TSS). The processor uses the DPL of the target code segment (the new CPL) to index the initial stack pointer for PL 0, PL 1, or PL 2.


:::copy to new stack.
As with intralevel calls, parameters for the subroutine are placed on the stack. To make privilege transitions transparent to the called procedure, the processor copies the parameters to the new stack. The count field of a call gate tells the processor how many doublewords (up to 31) to copy from the caller's stack to the new stack. If the count is zero, no parameters are copied.


The TSS does not have a stack pointer for a privilege level 3 stack, because privilege level 3 cannot be called by any procedure at any other privilege level.
Procedures that may be called from another privilege level and that require more than the 31 doublewords for parameters must use the saved SS:ESP link to access all parameters beyond the last doubleword copied.
A call via a call gate does not check the values of the words copied onto the new stack. The called procedure should check each parameter for validity. A later section discusses how the ARPL, VERR, VERW, LSL, and LAR instructions can be used to check pointer values.


TSS 全称task state segment,




NEW STACK:
OLD SS
OLD ESP
PARM 3
PARM 2
PARM 1
OLD CS
OLD EIP < ----- NEW SS:ESP


::::Near return
A return to a calling procedure within the current code segment (the segment currently pointed to by the CS register), sometimes referred to as an intrasegment return.
::::Far return
A return to a calling procedure located in a different segment than the current code segment, sometimes referred to as an intersegment return.
The RPL of the CS selector popped off the stack by the return instruction identifies the privilege level of the calling procedure.

Inter-privilege-level far return
A far return to a different privilege level than that of the currently executing program or procedure.


Store Local Descriptor Table Register (sldt)
Load Segment Limit (lsl)
Store Task Register (str)
Load Local Descriptor Table Register (lldt)
Load Task Register (ltr)
Verify a Segment for Reading or Writing (verr, verw)
Store Global/Interrupt Descriptor Table Register (sgdt, sidt)
Load Global/Interrupt Descriptor Table (lgdt, lidt)
Store Machine Status Word (smsw)
Load Machine Status Word (lmsw)
Load Access Rights (lar)
Load Segment Limit (lsl)
Clear Task-Switched (clts)
Adjust RPL Field of Selector (arpl)





The Requestor's Privilege Level (RPL) feature can prevent inappropriate use of pointers that could corrupt the operation of more privileged code or data from a less privileged level.





6.4  Page-Level Protection
Two kinds of protection are related to pages:
  1.  Restriction of addressable domain.
  2.  Type checking.





For example, it is possible to define a large data segment which has some subunits that are read-only and other subunits that are read-write. In this case, the page directory (or page table) entries for the read-only subunits would have the U/S and R/W bits set to x0, indicating no write rights for all the pages described by that directory entry (or for individual pages). This technique might be used, for example, in a UNIX-like system to define
a large data segment, part of which is read only (for shared data or ROMmed constants). This enables UNIX-like systems to define a "flat" data space as one large segment, use "flat" pointers to address within this "flat" space, yet be able to protect shared data, shared files mapped into the virtual space, and supervisor areas.




multitasking:

To provide efficient, protected multitasking, the 80386 employs several special data structures. It does not, however, use special instructions to control multitasking; instead, it interprets ordinary control-transfer instructions differently when they refer to the special data structures. The registers and data structures that support multitasking are:
  ●  Task state segment
  ●  Task state segment descriptor
  ●  Task register
  ●  Task gate descriptor
With these structures the 80386 can rapidly switch execution from one task to another, saving the context of the original task so that the task can be restarted later. In addition to the simple task switch, the 80386 offers two other task-management features:
1. Interrupts and exceptions can cause task switches (if needed in the system design). The processor not only switches automatically to the task that handles the interrupt or exception, but it automatically switches back to the interrupted task when the interrupt or exception has been serviced. Interrupt tasks may interrupt lower-priority interrupt tasks to any depth.
2. With each switch to another task, the 80386 can also switch to
another LDT and to another page directory. Thus each task can have a different logical-to-linear mapping and a different linear-to-physical mapping. This is yet another protection feature, because tasks can be isolated and prevented from interfering with one another.




32-bit task state segment

26.io map base
25.ldt
24.gs
23.fs
22.ds
21.ss
20.cs
19.es
18.edi
17.esi 
16.ebp
15.esp
14.ebx
13.edx
12.ecs
11.eax
10.eflags
9.eip
8.cr3(pdpr)
7.ss2
6.esp2
5.ss1
4.esp1
3.ss0
2.esp0
1.back link to previous tss


structure of page table:

directory




ELF 文件中包含了程序（代码）以及如何运行该程序的相关信息（元数据）。

C 语言的代码首先由预处理器（preprocessor）对 #include 和 #define 进行处理。具体来说，读入头文件，将所有的宏展开，这就是预处理（preprocess）。


接着，编译器对预处理器的输出进行编译，生成汇编语言（assemble language）的代码


，汇编语言的代码由汇编器（assembler）转换为机器语言，这个处理过程称为汇编
（assemble）。
汇编器的输出称为目标文件（object file）。一般来说，目标文件的扩展名是“.o”。


这里的解析（parse）也称为语法分析（syntax analyzing）。解析代码的程序模块称为解析器（parser）或语法分析器（syntax analyzer）。



语法分析只是对代码的表象进行分析，语义分析则是对表象之外的部分进行分析。举例来说，语义分析包括以下这些处理。
●● 区分变量为局部变量还是全局变量
●● 解析变量的声明和引用
●● 变量和表达式的类型检查
●● 检查在引用变量之前是否进行了初始化
●● 检查函数是否按照定义返回了结果


语法分析只是对代码的表象进行分析，语义分析则是对表象之外的部分进行分析。举例来
说，语义分析包括以下这些处理。
●● 区分变量为局部变量还是全局变量
●● 解析变量的声明和引用
●● 变量和表达式的类型检查
●● 检查在引用变量之前是否进行了初始化
●● 检查函数是否按照定义返回了结果


生 成 抽 象 语 法 树 后， 接 着 将 抽 象 语 法 树 转 化 为 只 在 编 译 器 内 部 使 用 的 中间代码（Intermediate Representation，IR）。

GCC 使用的是一种名为 RTL（Register Transfer Languange）的中间代码。


最后把中间代码转换为汇编语言，这个阶段称为代码生成（code generation）。负责代码生成的程序模块称为代码生成器（code generator）。



MMX 是MultiMedia eXtensions
MMX 和 SSE(Streaming SIMD Extensions)


,还有写 OS 内核时使用的系统寄存器(system register)、debug 时 使用的 debug 寄存器(debug register)以及 32 位环境下用不到的段寄存器(segment register)。



CF
status
carry flag
PF
status
parity flag
AF
status
auxiliary carry flag
ZF
status
zero flag
SF
status
sign flag
OF
status
overflow flag
DF
control
direction flag
TF
system
trap flag
IF
system
interrupt flag
IOPL
system
I/O privilege level
NT
system
nested task
RF
system
resume flag
VM
system
virtual 8086 mode
AC
system
alignment check
VIF
system
virtual interrupt flag
VIP
system
virtual interrupt pending
ID
system
ID flag




The Linux Standard Base (LSB) is a joint project by several Linux distributions under the organizational structure of the Linux Foundation to standardize the software system structure, including the filesystem hierarchy used in the Linux operating system.
https://refspecs.linuxfoundation.org/lsb.shtml
System V Application Binary Interface pdf
System V Application Binary Interface pdf
System V Application Binary Interface pdf



就 C 语言来说,寄存器就像是全局变量一样。因为是全局变量,所以我们很难得知什么时 候、哪一个函数更改了它的值。想象一下在编程的时候定义 6 个全局变量,只用这些变量编写 整个程序。这是非常困难的事情。要怎样做才能安全地访问寄存器呢?最保险的方法是,每次在调用别的函数前,把寄存器 的值保存到栈中。也就是说,在函数开始执行时,把所有寄存器的值压栈,而在函数内部执行 return 指令返回的时候,把寄存器的值出栈,恢复函数调用前的状态。通过这个方法,各个 函数就都可以随意使用所有的寄存器了。


OS provides a standard library to applications.


three piece code:::
http://pages.cs.wisc.edu/~remzi/OSTEP/Code/
http://pages.cs.wisc.edu/~remzi/OSTEP/Code/



Time sharing is one of the most basic techniques used by an OS to share a resource.



context switch, which gives the OS the ability to stop running one program and start running another on a given CPU; this time-sharing mechanism is employed by all modern OSes.



To understand what constitutes a process, we thus have to understand its machine state:



 By loading the code and static data into memory, by creating and ini- tializing a stack, and by doing other work as related to I/O setup, the OS has now (finally) set the stage for program execution. It thus has one last task: to start the program running at the entry point, namely main(). By jumping to the main() routine (through a specialized mechanism that we will discuss next chapter), the OS transfers control of the CPU to the newly-created process, and thus the program begins its execution.


process context:::;
The register context will hold, for a stopped process, the contents of its registers. 

context  switch::::
The register context will hold, for a stopped process, the contents of its registers. When a process is stopped, its registers will be saved to this memory location; by restoring these reg- isters (i.e., placing their values back into the actual physical registers), the OS can resume running the process. We’ll learn more about this technique known as a context switch in future chapters.


A process must be able to perform I/O and some other restricted oper- ations, but without giving the process complete control over the system. How can the OS and hardware work together to do so?


trap::::
To execute a system call, a program must execute a special trap instruc- tion. This instruction simultaneously jumps into the kernel and raises the privilege level to kernel mode; once in the kernel, the system can now per- form whatever privileged operations are needed (if allowed), and thus do the required work for the calling process. When finished, the OS calls a special return-from-trap instruction, which, as you might expect, returns into the calling user program while simultaneously reducing the privi- lege level back to user mode.



Limited Direct Execution Protocol


In the second (when running a process), the kernel sets up a few things (e.g., allocating a node on the process list, allocating memory) before us- ing a return-from-trap instruction to start the execution of the process; this switches the CPU to user mode and begins running the process. When the process wishes to issue a system call, it traps back into the OS, which handles it and once again returns control via a return-from-trap to the process. The process then completes its work, and returns from main(); this usually will return into some stub code which will properly exit the program (say, by calling the exit() system call, which traps into the OS). At this point, the OS cleans up and we are done



:::: how to switch out the running process;
The next problem with direct execution is achieving a switch between processes. Switching between processes should be simple, right? The OS should just decide to stop one process and start another. What’s the big deal? But it actually is a little bit tricky: specifically, if a process is running on the CPU, this by definition means the OS is not running. If the OS is not running, how can it do anything at all? (hint: it can’t) While this sounds almost philosophical, it is a real problem: there is clearly no way for the OS to take an action if it is not running on the CPU. Thus we arrive at the crux of the problem.

HOW TO GAIN CONTROL WITHOUT COOPERATION
A Non-Cooperative Approach

::: virtualize memory
there is a big monster waiting in the closet: memory. Virtualizing memory is complicated and requires us to understand many more intricate details about how the hardware and OS interact.



Understanding this fundamental OS ab- straction of memory is key to understanding how memory is virtualized.



In running a C program, there are two types of memory that are allo- cated. The first is called stack memory, and allocations and deallocations of it are managed implicitly by the compiler for you, the programmer; for this reason it is sometimes called automatic memory.


:::: segment error.
char *src = "hello";
char *dst;        // oops! unallocated
strcpy(dst, src); // segfault and die

:::: buffer overflow
    char *src = "hello";
    char *dst = (char *) malloc(strlen(src)); // too small!
    strcpy(dst, src); // work properly


IT COMPILED OR IT RAN ̸= IT IS CORRECT



In developing the virtualization of the CPU, we focused on a general mechanism known as limited direct execution (or LDE).



physical address = virtual address + base


TIP: HARDWARE-BASED DYNAMIC RELOCATION
With dynamic relocation, a little hardware goes a long way. Namely, a base register is used to transform virtual addresses (generated by the pro- gram) into physical addresses. A bounds (or limit) register ensures that such addresses are within the confines of the address space. Together they provide a simple and efficient virtualization of memory.



ASIDE: DATA STRUCTURE — THE FREE LIST
The OS must track which parts of free memory are not in use, so as to be able to allocate memory to processes. Many different data structures can of course be used for such a task; the simplest (which we will assume here) is a free list, which simply is a list of the ranges of the physical memory which are not currently in use.



Hardware Requirements
Privileged mode
Base/bounds registers
Ability to translate virtual addresses and check if within bounds
Privileged instruction(s) to update base/bounds
Privileged instruction(s) to register exception handlers
Ability to raise exceptions
Notes
Needed to prevent user-mode processes from executing privileged operations Need pair of registers per CPU to support address translation and bounds checks Circuitry to do translations and check limits; in this case, quite simple
OS must be able to set these values before letting a user program run
OS must be able to tell hardware what code to run if exception occurs
When processes try to access privileged instructions or out-of-bounds memory



segment voilation::::
What if we tried to refer to an illegal address, such as 7KB which is be- yond the end of the heap? You can imagine what will happen: the hard- ware detects that the address is out of bounds, traps into the OS, likely leading to the termination of the offending process. And now you know the origin of the famous term that all C programmers learn to dread: the segmentation violation or segmentation fault.




// get top 2 bits of 14-bit VA
Segment = (VirtualAddress & SEG_MASK) >> SEG_SHIFT
// now get offset
Offset  = VirtualAddress & OFFSET_MASK
if (Offset >= Bounds[Segment])
    RaiseException(PROTECTION_FAULT)
else
    PhysAddr = Base[Segment] + Offset
    Register = AccessMemory(PhysAddr)


:::::in some system: only have two segments.::::
some systems put code in the same segment as the heap and thus use only one bit to select which segment to use


::::::direction bit::::
The first thing we need is a little extra hardware support. Instead of just base and bounds values, the hardware also needs to know which way the segment grows.


::::code sharing register::::
support for segmentation grew, system designers soon realized that they could realize new types of efficiencies with a little more hardware support. Specifically, to save memory, sometimes it is useful to share certain memory segments between address spaces. In particular, code sharing is common and still in use in systems today.
To support sharing, we need a little extra support from the hardware, in the form of protection bits. Basic support adds a few bits per segment, indicating whether or not a program can read or write a segment, or per- haps execute code that lies within the segment. By setting a code segment to read-only, the same code can be shared across multiple processes, with- out worry of harming isolation; while each process still thinks that it is ac- cessing its own private memory, the OS is secretly sharing memory which cannot be modified by the process, and thus the illusion is preserved.

::::code segment::::
read && execute 

细粒度  粗粒度  段:::
::::Fine-grained vs. Coarse-grained Segmentation::::

paging 是为了 解决  memory fragmentation 问题。
::::external fragmentation:::
:::::Non-compacted and Compacted Memory::::




::::::segment have two problems:::::
1.external fragmentation
2.The second and perhaps more important problem is that segmentation still isn’t flexible enough to support our fully generalized, sparse address space. For example, if we have a large but sparsely-used heap all in one logical segment, the entire heap must still reside in memory in order to be accessed. In other words, if our model of how the address space is being used doesn’t exactly match how the underlying segmentation has been designed to support it, segmentation doesn’t work very well. We thus need to find some new solutions. Ready to find them?



::::context switch::::
what should the OS do on a context switch? You should have a good guess by now: the segment registers must be saved and restored. 



:::::CRUX: HOW TO MANAGE FREE SPACE:::::
How should free space be managed, when satisfying variable-sized re- quests? What strategies can be used to minimize fragmentation? What are the time and space overheads of alternate approaches?




free list::::manage free memory.
generic data structure used to manage free space in the heap is some kind of free list. 


::::internal fragmentation    external fragmentation::::


:::Correspondingly, we view physical memory as an array of fixed-sized slots called page frames:::

::::HOW TO VIRTUALIZE MEMORY WITH PAGES::::
How can we virtualize memory with pages, so as to avoid the prob- lems of segmentation? What are the basic techniques? How do we make those techniques work well, with minimal space and time overheads?


THE CRUX:
HOW TO VIRTUALIZE MEMORY WITH PAGES
How can we virtualize memory with pages, so as to avoid the prob- lems of segmentation? What are the basic techniques? How do we make those techniques work well, with minimal space and time overheads?


---------------------------------------------------------------------------

VPN     = (VirtualAddress & VPN_MASK) >> SHIFT
PTEAddr = PageTableBaseRegister + (VPN * sizeof(PTE))

offset   = VirtualAddress & OFFSET_MASK
PhysAddr = (PFN << SHIFT) | offset

---------------------------------------------------------------------------

// Extract the VPN from the virtual address
VPN = (VirtualAddress & VPN_MASK) >> SHIFT


// Form the address of the page-table entry (PTE)
PTEAddr = PTBR + (VPN * sizeof(PTE))

// Fetch the PTE
PTE = AccessMemory(PTEAddr)

// Check if process can access the page
if (PTE.Valid == False)
  RaiseException(SEGMENTATION_FAULT)
else if (CanAccess(PTE.ProtectBits) == False)
  RaiseException(PROTECTION_FAULT)
else
  // Access is OK: form physical address and fetch it
  offset   = VirtualAddress & OFFSET_MASK
  PhysAddr = (PTE.PFN << PFN_SHIFT) | offset
  Register = AccessMemory(PhysAddr)

---------------------------------------------------------------------------


HOW TO SPEED UP ADDRESS TRANSLATION
How can we speed up address translation, and generally avoid the extra memory reference that paging seems to require? What hardware support is required? What OS involvement is needed?


OS’s old friend: the hardware


translation-lookaside buffer, or TLB 
a better name would be an address-translation cache.



who handles a TLB miss? 


TLB VALID BIT ̸= PAGE TABLE VALID BIT


::::replacement policy.
THE CRUX: HOW TO DESIGN TLB REPLACEMENT POLICY Which TLB entry should be replaced when we add a new TLB entry? The goal, of course, being to minimize the miss rate (or increase hit rate)
and thus improve performance.



::::CRUX: HOW TO MAKE PAGE TABLES SMALLER?::::
Simple array-based page tables (usually called linear page tables) are too big, taking up far too much memory on typical systems. How can we make page tables smaller? What are the key ideas? What inefficiencies
arise as a result of these new data structures?


::::4kb page; 4MB page table size.::::
32-bit address space (2^32 bytes), with 4KB (2^12 byte) pages and a 4-byte page-table entry.
(2^32) / (2^12) 
2^(32-12)


make pages bigger::::
1. 2^(32-14)*4 = 1048576 1MB



multi-level page tables:::::
The basic idea behind a multi-level page table is simple. First, chop up the page table into page-sized units; then, if an entire page of page-table entries (PTEs) is invalid, don’t allocate that page of the page table at all. To track whether a page of the page table is valid (and if valid, where it is in memory), use a new structure, called the page directory. The page directory thus either can be used to tell you where a page of the page table is, or that the entire page of the page table contains no valid pages.




1.In singlelevel pagetable you need the whole table to access even a small amount of data(less memory references). i.e 2^20 pages each PTE occupying 4bytes as you assumed.
Space required to access any data is 2^20 * 4bytes = 4MB

2.Paging pages is multi-level paging.In multilevel paging it is more specific, you can with the help of multi-level organization decide which specific page among the 2^20 pages your data exists, and select it . So here you need only that specific page to be in the memory while you run the process.
In the 2 level case that you discussed you need 1st level pagetable and then 1 of the 2^10 pagetables in second level. So, 1st level size = 2^10 * 4bytes = 4KB 2nd level we need only 1 among the 2^10 pagetables = so size is 2^10 * 4bytes = 4KB

Total size required is now : 4KB + 4KB = 8KB.

Final comparision is 4MB vs 8KB .





:::::THE CRUX: HOW TO GO BEYOND PHYSICAL MEMORY
How can the OS make use of a larger, slower device to transparently pro- vide the illusion of a large virtual address space?



how will the OS know where to find the desired page? In many systems, the page table is a natural place to store such information. Thus, the OS could use the bits in the PTE normally used for data such as the PFN of the page for a disk address. When the OS receives a page fault for a page, it looks in the PTE to find the address, and issues the request to disk to fetch the page into memory.




● Descriptors contain a field called the descriptor privilege level (DPL).
● Selectors contain a field called the requestor's privilege level (RPL). The RPL is intended to represent the privilege level of the procedure that originates a selector.
● An internal processor register records the current privilege level (CPL). Normally the CPL is equal to the DPL of the segment that the processor is currently executing. CPL changes as control is transferred to segments with differing DPLs.




Normally the CPL is equal to the DPL of the segment that the processor is currently executing. CPL may, however, be greater than DPL if the conforming bit is set in the descriptor of the current executable segment. The processor keeps a record of the CPL cached in the CS register; this value can be different from the DPL in the descriptor of the code segment.

::: the only case:::
the only case when CPL may be unequal to the DPL of the current executable segment.

An executable segment whose descriptor has the conforming bit set is called a conforming segment. The conforming-segment mechanism permits sharing of procedures that may be called from various privilege levels but should execute at the privilege level of the calling procedure. Examples of such procedures include math libraries and some exception handlers. When control is transferred to a conforming segment, the CPL does not change.



TSS在任务切换过程中起着重要作用，通过它实现任务的挂起和恢复。所谓任务切换是指，挂起当前正在执行的任务，恢复或启动另一任务的执行。在任务切换过程中，首先，处理器中各寄存器的当前值被自动保存到TR（任务寄存器）所指定的TSS中；然后，下一任务的TSS的选择子被装入TR；最后，从TR所指定的TSS中取出各寄存器的值送到处理器的各寄存器中。由此可见，通过在TSS中保存任务现场各寄存器状态的完整映象，实现任务的切换。   



