initial program
bootstrap program
read-only memory (ROM
 bootstrap program locate the operating-system kernel and load it into memory.
system prcess system daemon
hardware interrupt   software interrupt, system call.


When the CPU is interrupted, it stops what it is doing and immediately transfers execution to a fixed location. The fixed location usually contains the starting address where the service routine for the interrupt is located.

More recent architectures store the return address on the system stack. 
 small computer-systems interface (SCSI) controller
 A device controller maintains some local buffer storage and a set of special-purpose registers. 
 device driver  device controller 


 To start an I/O operation, the device driver loads the appropriate registers within the device controller. The device controller, in turn, examines the contents of these registers to determine what action to take (such as “read a character from the keyboard”). The controller starts the transfer of data from the device to its local buffer. Once the transfer of data is complete, the device controller informs the device driver via an interrupt that it has finished its operation. The device driver then returns control to the operating system, possibly returning the data or a pointer to the data if the operation was a read. For other operations, the device driver returns status information.


 multiprocessor systems (also known as parallel systems or multicore systems) 

 The set of jobs in memory can be a subset of the jobs kept in the job pool. 


  job scheduling, if several jobs are ready to be brought into memory, and if there is not enough room for all of them, 

swapping, virtual memory

al ax eax disp8 disp32  cl cx ecx dl dx edx bl bx ebx SIB Mode ah sp esp ch bp ebp esi dh si esi edi bh di edi

https://www.byclb.com/TR/Tutorials/microprocessors/ch3_1.htm
SIP: scaled index address mode: just for index array.


http://52.80.126.45:8081/


 curl -vX GET http://52.80.126.45:8081/api/aikfs/v1/huxing/user/history/list
jia-test.lbadvisor.com/
 curl -vX GET http://jia-test.lbadvisor.com/api/aikfs/v1/huxing/user/history/list
https://www.ragestorm.net/downloads/286intel.txt


●  A displacement element in the instruction.
●  A base register.
●  An index register. The index register may be automatically multiplied by a scaling factor of 2, 4, or 8.
查数组， 一个基地址， 一个

 MOD-REG-R/M: mode: 8 bit, reg: 8 big, r/m: regist or memory. 



https://github.com/QSCTech/zju-icicles


ret: 
return save previous EIP on stack.



memory:::

d: offset, displacement.
p: p to page table,.
logical address: 
cpu: p * 8 + d
Memory Paging is yet another 386 feature that permits extending the address space far beyond 4 Gb.

Address generated by CPU (logical address) is divided into:

Page number p is an index into a page table that contains base address of each page in physical memory.

Page offset d is a displacement, combined with base address to define the physical memory address that is sent to the memory unit.





protected mode:::
32-bit Protected Mode supports much larger data structures than Real mode.

Because code, data, and stack reside in the same segment, each segment register can hold the same value that never needs to change.

Rather than using a formula (such as CS:IP) to determine the physical address, protected mode processors use a look up table.

Segment registers simply point to OS data structures that contain the information needed to access a location.

Protected mode uses privilege levels to maintain system integrity and security.

Programs cannot access data or code that is in a higher privilege level.

(Segment value exchanges at the same privilege level are allowed.)




segment registers in protected mode:


Segment registers are called selectors when operating in protected mode.
Segment registers are called selectors when operating in protected mode.

In protected mode, segment registers simply point to data structures called segment descriptors that contain the information needed to access a physical memory location.


Segment selector is a segment register, containing the selector value:

  Segment selector

13-bit index field selects one of 8,192 segment descriptors.

TI (table indicator) specifies segment descriptor, which can be in

GDT - global descriptor table (one for all programs)

LDT - local descriptor table (typically one for each program, more can exist.)

IDT - interrupt descriptor table.


--------------------------


protected mode architecture:
Segment register (segment selector) -> segment descriptor -> physical memory

--------------------------

Understanding segments is an essential part of programming in assembly language.

--------------------------
protected mode:::
For example, a code fetch always uses the current CS. A protected mode fetch starts by multiplying CS by 8 and then adding the descriptor base register. The 386 then reads an entire 8 byte record from the descriptor table. The entry describes the start of the segment; the processor adds the current instruction pointer to this start to get an effective address.


A data access behaves the same way. A load from location DS:1000 makes the processor read a descriptor by shifting DS left 3 bits (i.e., times 8), adding the table's base address (stored in the 386's on-board descriptor table register), and reading the 8 byte descriptor at this address. The descriptor contains the segment's start address, which is added to the offset in the instruction (in this case 1000). Offsets, and segment start addresses, are 32 bit numbers - it's really easy to reference any location in memory.

Every memory access works through these 8 byte descriptors. If they were stored only in user RAM the 386's throughput would be pathetic, since each memory reference needs the information. Can you imagine waiting for an 8 byte read before every memory access? Actually, the processor caches a descriptor for each selector (one for CS, one for DS, etc) on-chip, so the segment translation requires no overhead. However, every load of a selector (like MOV DS,AX or POP ES) will make the 386 stop and read all 8 bytes to it's internal cache, slowing things down just a bit.